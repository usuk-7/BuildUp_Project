"""
🎒 **0-1 배낭 문제 (0-1 Knapsack Problem) - 2차원 DP 버전**

📋 **문제 설명**:
- N개의 물건과 최대 무게 K인 배낭이 주어짐
- 각 물건은 무게(w)와 가치(v)를 가짐
- 배낭에 넣을 수 있는 물건들의 가치 합의 최댓값을 구하는 문제
- 각 물건은 0개 또는 1개만 선택 가능 (0-1 배낭)

🧠 **알고리즘**: 동적 계획법 (Dynamic Programming) - 2차원 배열 사용
⏰ **시간 복잡도**: O(N × K)
💾 **공간 복잡도**: O(N × K) - 메모리 사용량이 많지만 이해하기 쉬움

🔄 **1차원 DP와의 차이점**:
- 1차원: 공간 최적화, 역방향 순회 필요
- 2차원: 직관적 이해, 모든 상태 저장, 순방향 순회 가능
"""

# 📥 입력: n(물건 개수), k(배낭 최대 무게)
n, k = map(int, input().split())

# 🎯 2차원 DP 배열 초기화: dp[i][j] = i번째 물건까지 고려했을 때, 무게 j일 때의 최대 가치
# 행: 물건 인덱스 (0~n), 열: 무게 (0~k)
# 인덱스 1부터 사용하므로 크기는 (n+1) × (k+1)
dp = [[0 for i in range(k+1)] for i in range(n+1)]

# 🔄 각 물건에 대해 DP 테이블 채우기
for i in range(1, n+1):  # i번째 물건 (1부터 n까지)
    # 📥 현재 물건의 [무게, 가치] 입력
    # x[0]: 무게(weight), x[1]: 가치(value)
    x = list(map(int, input().split()))
    
    # 🎯 모든 가능한 무게에 대해 최적해 계산
    for j in range(1, k+1):  # j: 현재 고려하는 배낭 무게
        
        # ⚠️ **경우 1**: 현재 물건의 무게가 배낭 용량보다 큰 경우
        if x[0] > j:
            # 현재 물건을 넣을 수 없으므로 이전 상태 그대로 유지
            # dp[i-1][j]: (i-1)번째 물건까지 고려했을 때 무게 j의 최대 가치
            dp[i][j] = dp[i-1][j]
        
        # ✅ **경우 2**: 현재 물건을 넣을 수 있는 경우
        else:
            # 🤔 선택의 기로:
            # 1. dp[i-1][j]: 현재 물건을 넣지 않는 경우
            #    → (i-1)번째까지의 물건으로 무게 j일 때의 최대 가치
            # 2. dp[i-1][j-x[0]] + x[1]: 현재 물건을 넣는 경우
            #    → 무게 x[0]를 빼고 가치 x[1]을 더함
            #    → (i-1)번째까지의 물건으로 무게 (j-x[0])일 때의 최대 가치 + 현재 물건 가치
            # 🎯 두 경우 중 더 큰 값을 선택
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-x[0]] + x[1])

# 📤 결과 출력: n개의 물건을 모두 고려했을 때, 무게 k일 때의 최대 가치
print(dp[n][k])

"""
🔍 **2차원 DP 동작 예시**:

예시 입력:
4 7    # 물건 4개, 배낭 최대 무게 7
6 13   # 물건1: 무게 6, 가치 13
4 8    # 물건2: 무게 4, 가치 8  
3 6    # 물건3: 무게 3, 가치 6
5 12   # 물건4: 무게 5, 가치 12

초기 DP 테이블 (모든 값이 0):
      무게 0  1  2  3  4  5  6  7
물건0   0   0  0  0  0  0  0  0
물건1   0   0  0  0  0  0  0  0
물건2   0   0  0  0  0  0  0  0
물건3   0   0  0  0  0  0  0  0
물건4   0   0  0  0  0  0  0  0

물건1 (무게6, 가치13) 처리 후:
      무게 0  1  2  3  4  5  6   7
물건0   0   0  0  0  0  0  0   0
물건1   0   0  0  0  0  0  13  13
...

최종 DP 테이블:
      무게 0  1  2  3  4  5  6   7
물건0   0   0  0  0  0  0  0   0
물건1   0   0  0  0  0  0  13  13
물건2   0   0  0  0  8  8  13  13
물건3   0   0  0  6  8  8  14  19
물건4   0   0  0  6  8  12 14  20

결과: dp[4][7] = 20

🎯 **핵심 포인트**:

1️⃣ **2차원 DP의 의미**:
   - dp[i][j]: i번째 물건까지 고려했을 때, 무게 j일 때의 최대 가치
   - 각 셀은 이전 상태들을 참조하여 계산

2️⃣ **점화식**:
   if 무게 > j: dp[i][j] = dp[i-1][j]                    (물건을 넣을 수 없음)
   else:        dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)  (넣지않음 vs 넣음)

3️⃣ **메모리 사용**:
   - 모든 중간 상태를 저장: O(N × K) 공간
   - 1차원 버전보다 메모리 사용량 많음

4️⃣ **장점**:
   - 직관적이고 이해하기 쉬움
   - 역추적(backtracking)으로 선택된 물건 확인 가능
   - 디버깅이 용이함

5️⃣ **단점**:
   - 메모리 사용량이 많음
   - 큰 입력에서 메모리 초과 가능성
"""