"""
🎒 **0-1 배낭 문제 (0-1 Knapsack Problem) 해결**

📋 **문제 설명**:
- N개의 물건과 최대 무게 K인 배낭이 주어짐
- 각 물건은 무게(w)와 가치(v)를 가짐
- 배낭에 넣을 수 있는 물건들의 가치 합의 최댓값을 구하는 문제
- 각 물건은 0개 또는 1개만 선택 가능 (0-1 배낭)

🧠 **알고리즘**: 동적 계획법 (Dynamic Programming)
⏰ **시간 복잡도**: O(N × K)
💾 **공간 복잡도**: O(K) - 1차원 배열 최적화
"""

# 📥 입력: n(물건 개수), k(배낭 최대 무게)
n, k = map(int, input().split())

# 🎯 DP 배열 초기화: dp[i] = 무게 i일 때 얻을 수 있는 최대 가치
# 인덱스 0부터 k까지 사용하므로 크기는 k+1
dp = [0] * (k + 1)

# 🔄 각 물건에 대해 배낭 문제 해결
for i in range(n):
    # 📥 현재 물건의 무게(w)와 가치(v) 입력
    w, v = map(int, input().split())
    
    # ⚠️ **중요**: 역방향 순회 (k부터 w까지 감소)
    # 순방향으로 하면 같은 물건을 여러 번 사용하는 문제 발생
    # 역방향으로 하면 현재 물건을 한 번만 사용하도록 보장
    for j in range(k, w-1, -1):
        # 🤔 선택의 기로:
        # 1. dp[j]: 현재 물건을 넣지 않는 경우의 가치
        # 2. dp[j-w] + v: 현재 물건을 넣는 경우의 가치
        #    - dp[j-w]: 무게 (j-w)일 때의 최대 가치
        #    - v: 현재 물건의 가치
        # 🎯 두 경우 중 더 큰 값을 선택
        dp[j] = max(dp[j], dp[j-w] + v)

# 📤 결과 출력: 배낭 최대 무게 k일 때의 최대 가치
print(dp[k])

"""
🔍 **알고리즘 동작 예시**:

예시 입력:
4 7    # 물건 4개, 배낭 최대 무게 7
6 13   # 무게 6, 가치 13
4 8    # 무게 4, 가치 8
3 6    # 무게 3, 가치 6
5 12   # 무게 5, 가치 12

초기 상태: dp = [0, 0, 0, 0, 0, 0, 0, 0]

물건 1 (w=6, v=13) 처리 후:
dp = [0, 0, 0, 0, 0, 0, 13, 13]

물건 2 (w=4, v=8) 처리 후:
dp = [0, 0, 0, 0, 8, 8, 13, 13]

물건 3 (w=3, v=6) 처리 후:
dp = [0, 0, 0, 6, 8, 8, 14, 19]

물건 4 (w=5, v=12) 처리 후:
dp = [0, 0, 0, 6, 8, 12, 14, 20]

결과: 20

🎯 **핵심 포인트**:

1️⃣ **역방향 순회의 이유**:
   - 순방향: j=w부터 k까지 → 같은 물건 중복 사용 가능
   - 역방향: j=k부터 w까지 → 같은 물건 한 번만 사용

2️⃣ **점화식**:
   dp[j] = max(dp[j], dp[j-w] + v)
   - dp[j]: 물건을 넣지 않는 경우
   - dp[j-w] + v: 물건을 넣는 경우

3️⃣ **공간 최적화**:
   - 2차원 배열 대신 1차원 배열 사용
   - 메모리 사용량: O(NK) → O(K)

4️⃣ **경계 조건**:
   - j >= w일 때만 물건을 넣을 수 있음
   - range(k, w-1, -1)로 자동 처리
"""