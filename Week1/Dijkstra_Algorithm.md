# 📝 Dijkstra 알고리즘과 Heap 기반 최단경로 탐색

## 1️⃣ 개요

- **다익스트라 알고리즘**은 가중치 그래프에서 출발점으로부터 모든 목표지점까지의 최단 경로를 구하는 알고리즘이다.
- 현대 물류 시스템에서도 차량의 배송 경로 최적화, 내비게이션, 교통 네트워크 분석 등 여러 분야에 널리 활용된다.
- 다익스트라 알고리즘은 우선순위 큐(min-heap) 자료구조와 결합하여 구현할 때 각 단계에서 미방문 노드 중 최소 거리를 빠르게 선택할 수 있으므로 효율성이 크게 향상된다.

- 물류 배송 경로 최적화와 같이 복잡한 도로 네트워크에서 최단시간 경로를 계산하는 문제에 다익스트라+힙 기법을 적용하면, 실시간으로 경로를 탐색하고 최적의 배송 계획을 세울 수 있다.

## 2️⃣ Dijkstra 알고리즘 소개

- 다익스트라 알고리즘(Dijkstra Algorithm)은 단일 출발점에서 그래프 내 다른 모든 정점까지의 최단 경로를 구하는 대표적인 최단경로 알고리즘이다.
- 그래프의 간선(weight)은 0 이상, 즉 음수 가중치가 없어야 정확하게 동작한다. 알고리즘의 핵심 원리는 탐욕법으로, 아직 방문하지 않은 노드 중 현재까지 거리가 가장 짧은 노드를 반복적으로 선택하여 인접 노드들의 거리를 갱신(relax)하는 것이다.
- 이 과정에서 한 번 선택된 노드는 다시 갱신할 필요가 없으므로 최종적으로 각 정점까지의 최단 거리가 확정된다.

### ✅ 예시로 이해하기

```python
graph = {
    'A' : {'B' : 3, 'C' : 6, 'D' : 7},
    'B' : {'A' : 3, 'C' : 1},
    'C' : {'A' : 6, 'B' : 1, 'D' : 1},
    'D' : {'A' : 7, 'C' : 1}
}
```

A에서 각 노드까지의 최단 거리를 구해보자.

먼저 A에서 각 노드까지의 거리를 나타내는 표이다.

| A | B | C | D |
|:-:|:-:|:-:|:-:|
| 0 |inf|inf|inf|

A부터 탐색하여 거리 수정

| A | B | C | D |
|:-:|:-:|:-:|:-:|
| 0 | 3 | 6 | 7 |

그 다음 B에서 탐색하여 거리 수정

| A | B | C | D |
|:-:|:-:|:-:|:-:|
| 0 | 3 | 3 + 1 = 4 | 7 |

그 다음 C에서 탐색하여 거리 수정

| A | B | C | D |
|:-:|:-:|:-:|:-:|
| 0 | 3 | 4 | 4 + 1 = 5 |

그 다음 D에서 탐색하여 거리 수정

| A | B | C | D |
|:-:|:-:|:-:|:-:|
| 0 | 3 | 4 | 5 |

구체적인 작동 과정은 다음과 같다.

1. 출발 노드를 설정
2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장
3. 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택
4. 해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신
5. 위 과정에서 3 ~ 4번을 반복

### ✅ 시간복잡도

Heap(우선순위 큐)을 사용하지 않는 다익스트라 알고리즘의 **시간복잡도는 O(V²)** 이다.

## 3️⃣ Heap 자료구조의 특징과 활용

- Heap(힙)은 **우선순위 큐(priority queue)** 를 구현할 때 자주 사용하는 완전 이진 트리(Complete Binary Tree) 기반의 자료구조이다.

- Heap은 크게 두 가지 종류가 있으며, 이들은 다음과 같은 특징을 가진다:

| 종류       | 특징                              | 루트 노드의 값 |
| -------- | ------------------------------- | -------- |
| Max Heap | 부모 노드 ≥ 자식 노드 (값이 클수록 높은 우선순위)  | 항상 최댓값   |
| Min Heap | 부모 노드 ≤ 자식 노드 (값이 작을수록 높은 우선순위) | 항상 최솟값   |

### ✅ 배열 인덱스 기반 규칙

#### 노드의 위치와 관계

- 어떤 노드가 **인덱스 `i`**에 있다면:
  - 왼쪽 자식: 인덱스 `2i + 1`
  - 오른쪽 자식: 인덱스 `2i + 2`
  - 부모 노드: 인덱스 `(i - 1) // 2`

### ✅ 예시로 이해하기

다음과 같은 **Min Heap**이 있다고 가정해 보자.

```
        4
       / \
     10   6
     / \
   20   15
```

이 트리는 배열로 다음과 같이 표현된다.

| 인덱스 | 값  |
| --- | -- |
| 0   | 4  |
| 1   | 10 |
| 2   | 6  |
| 3   | 20 |
| 4   | 15 |

- Heap에서 **삽입(insert)** 과 삭제(delete, 특히 루트 노드 삭제) 연산의 시간복잡도는 **O(log n)** 이다.
- 이 복잡도는 **트리의 높이(log n)** 에 비례하는 연산이 필요하기 때문이다.

## 4️⃣ Heap 기반 Dijkstra 알고리즘의 동작 흐름

### ✅ 예시로 이해하기

```python
graph = {
    'A' = {'B' : 2, 'C' : 5, 'D' : 1}
    'B' = {'C' : 3, 'D' : 2}
    'C' = {'B' : 3}
    'D' = {'C' : 3, 'E' : 5}
    'E' = {'C' : 1, 'F' : 2}
    'F' = {'C' : 5}
}
```
 
Dijkstra 알고리즘에 Min Heap을 활용해보자.

| A | B | C | D | E | F |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 0 |inf|inf|inf|inf|inf|

`Heap = [(0, 'A')]  # (거리, 노드)`

| A | B | C | D | E | F |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 0 | 2 | 5 | 1 |inf|inf|

`Heap = [(1, 'D'), (2, 'B'), (5, 'C')]`

| A | B | C | D | E | F |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 0 | 2 | 5->4 | 1 | inf->2 | inf |

`Heap = [(2, 'B'), (1+1, 'E'), (1+3, 'C'), (5, 'C')]`

| A | B | C | D | E | F |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 0 | 2 | 4 | 1 | 2 | inf |

`Heap = [(2, 'E'), (4, 'C'), (5, 'C')]`

| A | B | C | D | E | F |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 0 | 2 | 4->3 | 1 | 2 | inf->4 |

`Heap = [(2+1, 'C'), (4, 'C'), (2+2, 'F'), (5, 'C')]`

Heap에 남은 나머지 값으로는 더 이상의 최단경로 찾을 수 없음.

#### ✅ 결과

| A | B | C | D | E | F |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 0 | 2 | 3 | 1 | 2 | 4 |

### ✅ 시간복잡도

Heap(우선순위 큐)을 사용하는 다익스트라 알고리즘의 **시간복잡도는 O((V + E) log V)** 이다.

## 5️⃣ 참고 문제 : 백준 1400번 화물차

### ✅ 문제

화물차가 출발지 창고에서 짐을 싣고 배송지 창고까지 짐을 운반하려고 한다. 이 도시의 도로망을 나타낸 지도의 예는 다음과 같다.

```
#A##0##1#
.#..#..#.
.#..#..#.
.###2#.B.
```

도로망에서 차들은 동, 서, 남, 북의 방향으로만 이동할 수 있고, 지도의 각 문자는 다음과 같은 의미를 가진다.
- 'A'는 출발지 창고를 나타내고, 지도에서 유일하다.
- 'B'는 배송지 창고를 나타내고, 지도에서 유일하다.
- '.'은 차가 들어갈 수 없는 곳을 나타낸다.
- '#'은 각 도로 셀을 나타낸다. '#'은 기껏해야 두 개의 다른 도로 셀, 또는 교차로, 창고와 인접하다.
- 숫자 [0-9]는 신호등에 의해 제어되는 교차로를 나타낸다. 교차로는 적어도 세 개의 도로 셀과 인접하다. 교차로들은 0부터 9까지의 번호로 표시된다. 만일 번호 k를 가진 교차로가 있으면, 반드시 0부터 k까지 번호를 가진 교차로가 존재한다. 교차로의 신호등에 대한 설명은 아래에 나온다.

차량의 이동은 다음과 같은 방식으로 분석된다.

- 화물차가 인접한 도로 셀, 또는 교차로, 창고로 이동하는 데 걸리는 시간을 단위 시간이라고 가정한다. 차량이 어떤 위치에서 멈춰 서 있는 시간도 단위 시간으로 측정된다.
- 화물차가 진입하려는 방향으로 파란불이 켜져 있을 때만 교차로로 들어갈 수 있다. 그러나 교차로에 들어간 차량은 언제든지 임의의 방향으로 나갈 수 있다.
- 교차로의 신호등은 동서 방향과 남북 방향, 두 개의 신호가 주기적으로 켜진다. 교차로의 신호는 초기에 동서 방향 또는 남북 방향이 될 수 있다. 교차로의 신호 주기를 나타내는 값 "a b"는 동서 방향의 신호가 a 시간 켜지고, 남북 방향의 신호가 b 시간 켜짐을 의미한다. 예를 들어, 초기에 남북 방향의 신호가 켜지고 주기 값이 "2 3"이면, 차량이 1-3 시간에 남북 방향의 신호가 켜지고, 4-5 시간은 동서 방향, 6-8 시간은 다시 남북 방향의 신호가 켜진다.

출발지 창고에서 배송지 창고까지 최단 경로를 구하는 프로그램을 작성하시오.

### ✅ 입력

입력은 여러 개의 테스트 케이스로 구성된다. 각 테스트 케이스의 첫째 줄에는 두 개의 정수 m과 n이 주어진다, 여기서 m은 지도를 나타내는 행렬의 행의 크기이고 n은 열의 크기이다(2 ≤ m, n ≤ 20).

그 다음 m개의 줄에는 각 줄마다 n개의 문자가 주어진다. 각 문자는 지도를 구성하는 문자인 '#', '.', 'A', 'B', [0-9]로 구성된다.

그 다음 줄부터는 각 교차로에 대한 정보가 주어진다. 교차로 번호가 0인 것부터 오름차순으로 한 줄에 하나씩 주어진다. 각 줄에는 교차로 번호 i와 '-' 또는 '|', 그 다음으로 두 개의 정수 ai와 bi (1 ≤ ai, bi ≤ 20) 가 빈칸을 사이에 두고 주어진다, 여기서 '-'는 신호등이 초기에 동서 방향의 신호가 켜짐을 나타내고, '|'는 남북 방향의 신호가 켜짐을 나타낸다. ai와 bi는 각각 동서 방향 신호가 켜 있는 시간과 남북 방향 신호가 켜 있는 시간을 나타낸다.

각 테스트 케이스 사이에는 빈 줄 하나가 들어 있고, 두 개의 0으로 시작되는 테스트 케이스는 입력의 끝을 나타낸다. 테스트 케이스는 20개를 넘지 않는다고 가정해도 된다.

### ✅ 출력

각 테스트 케이스에 대해, 한 줄에 한 개의 정수를 출력한다. 이 정수는 출발지 창고에서 배송지 창고까지 차량으로 이동하는 데 걸리는 최소 시간이다. 만일 차량이 배송지 창고까지 도달할 수 없으면 "impossible"을 출력한다.

### ✅ 예제 입력

```
3 4
A##B
#..#
####

4 9
#A##0##1#
.#..#..#.
.#..#..#.
.###2#.B.
0 - 1 17
1 | 3 5
2 - 2 4

2 2
A.
.B

0 0 
```

### ✅ 예제 출력

```
3
17
impossible
```

---

## 6️⃣ 문제 해결 및 알고리즘 분석

```python
import heapq

EW, NS = 0, 1

def isValid(Type):
    """벽('.')이 아닌 모든 셀은 유효함 - 벽 검사 함수"""
    return Type != '.'

def entryTime(t, d, Type, ew, ns):
    """
    신호등이 있는 교차로에 진입하는 시간 계산
    
    Parameters:
    - t: 현재 시간
    - d: 진입 방향 (EW=0: 동서, NS=1: 남북)
    - Type: 신호등 타입 ('-': 동서만, '|': 남북만)
    - ew: 동서 방향 신호 지속 시간 (1~20)
    - ns: 남북 방향 신호 지속 시간 (1~20)
    """
    if Type == '-':  # 동서 방향만 통과 가능한 신호등
        r = t % (ew + ns)
        if d == EW and r >= ew:
            t += (ew + ns - r)
        if d == NS and r < ew:
            t += (ew - r)
    elif Type == '|':  # 남북 방향만 통과 가능한 신호등
        r = t % (ew + ns)
        if d == EW and r < ns:
            t += (ns - r)
        if d == NS and r >= ns:
            t += (ns + ew - r)
    return t + 1

def drive(Map, t_lights):
    """다익스트라 알고리즘을 이용한 최단 경로 탐색"""
    global m, n
    
    # 최단 시간 저장 배열 초기화
    seen = [[float('inf') for _ in range(n)] for _ in range(m)]

    # 시작점 A 찾기 - 문제 조건상 A는 항상 존재
    ar, ac = 0, 0
    for i in range(m):
        for j in range(n):
            if Map[i][j] == 'A':
                ar, ac = i, j
                break
        if Map[i][j] == 'A':
            break

    # 우선순위 큐 초기화 (시간, 행, 열)
    pq = [(0, ar, ac)]
    seen[ar][ac] = 0

    # 다익스트라 알고리즘 실행
    while pq:
        t, i, j = heapq.heappop(pq)

        # 목적지 B에 도달한 경우
        if Map[i][j] == 'B':
            return t

        # 이미 더 빠른 경로로 방문한 경우 건너뛰기
        if t > seen[i][j]:
            continue

        # 상하좌우 네 방향 탐색
        directions = [(0, -1, EW), (0, 1, EW), (-1, 0, NS), (1, 0, NS)]

        for di, dj, direction in directions:
            ni, nj = i + di, j + dj

            # 지도 범위 내이고 유효한 셀인지 확인
            if 0 <= ni < m and 0 <= nj < n and isValid(Map[ni][nj]):
                cell_type = Map[ni][nj]
                ew, ns = 0, 0  # 기본값 설정

                if cell_type.isdigit():
                    idx = int(cell_type)
                    # 문제 조건상 신호등 정보는 항상 존재하지만 안전을 위해 체크
                    if idx < len(t_lights) and t_lights[idx] is not None:
                        cell_type, ew, ns = t_lights[idx]

                # 다음 시간 계산
                next_time = entryTime(t, direction, cell_type, ew, ns)

                # 더 빠른 경로를 발견한 경우 업데이트
                if next_time < seen[ni][nj]:
                    seen[ni][nj] = next_time
                    heapq.heappush(pq, (next_time, ni, nj))

    # B에 도달할 수 없는 경우
    return -1

def main():
    """
    메인 함수 - 문제 조건이 완벽하게 보장되는 간소화된 버전
    
    🎯 가정:
    - 모든 입력은 올바른 형식
    - "0 0"으로 정상 종료 보장
    - 빈 줄로 신호등 정보 구분 보장
    - 모든 숫자는 정수 형태
    """
    global m, n

    while True:
        # 지도 크기 입력 - 문제 조건상 항상 올바른 형식
        m, n = map(int, input().split())
        if m == 0 and n == 0:
            break

        # 지도 정보 입력 - 문제 조건상 정확히 m줄
        Map = []
        for _ in range(m):
            Map.append(input().strip())

        # 신호등 정보 저장 - 동적 리스트 사용
        t_lights = []

        # 신호등 정보 읽기 - 빈 줄까지 읽음
        while True:
            line = input().strip()
            if not line:  # 빈 줄이면 신호등 입력 종료
                break

            # 신호등 정보 파싱 - 문제 조건상 항상 올바른 형식
            parts = line.split()
            index = int(parts[0])
            d = parts[1]
            ew = int(parts[2])
            ns = int(parts[3])

            # 리스트 크기를 동적으로 확장
            while len(t_lights) <= index:
                t_lights.append(None)

            # 올바른 인덱스에 저장
            t_lights[index] = (d, ew, ns)

        # 최단 경로 계산
        time = drive(Map, t_lights)

        # 결과 출력
        if time > 0:
            print(time)
        else:
            print('impossible')

if __name__ == '__main__':
    main()
```

---
