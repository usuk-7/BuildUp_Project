# 📝 동적 계획법(Dynamic Programming, DP)

동적 계획법(DP)은 **복잡한 문제를 작은 하위 문제로 나누고, 그 결과를 저장하며 최적 해를 찾는 알고리즘 기법**이다. 중복되는 계산을 피함으로써 **시간 복잡도를 크게 줄일 수 있다**

---

## ✅ 1. 언제 DP를 사용할까?

다음 조건을 만족할 때 DP를 사용할 수 있다:

- **최적 부분 구조**  
  전체 문제의 최적해가 **부분 문제의 최적해로 구성**될 수 있을 때

- **중복되는 부분 문제**  
  동일한 부분 문제를 여러 번 계산하게 될 때 (재귀 호출에서 동일한 호출 반복)

---

## 🧩 2. 접근 방식

| 방식 | 설명 | 예시 |
|------|------|------|
| Top-Down (재귀 + 메모이제이션) | 큰 문제를 작은 문제로 나누며 풀고, 결과를 캐시에 저장 | 피보나치 수열 (재귀) |
| Bottom-Up (반복문 + 테이블) | 작은 문제부터 차례로 해결해가며 최종 답 도출 | 계단 오르기, 배낭 문제 등 |

---

## 📘 3. 참고 문제 : 평범한 배낭
## 문제 설명

이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

---

## 입력

첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

---

## 출력

한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

---

## 예제 입력

```
4 7
6 13
4 8
3 6
5 12
```

---

## 예제 출력

```
14
```

---

## 예제 풀이 설명
| 물건 번호 | 무게(W) | 가치(V) |
| ----- | ----- | ----- |
| 1번    | 6     | 13    |
| 2번    | 4     | 8     |
| 3번    | 3     | 6     |
| 4번    | 5     | 12    |


* 무게 합이 **K 이하(<=7)** 가 되도록 물건을 선택하되, 가치의 합을 최대화 해야함

## 🔍 가능한 조합 분석 
## ✅ 1. 물건을 하나만 선택하는 경우
* 1번: 무게 6 → OK, 가치 13

* 2번: 무게 4 → OK, 가치 8

* 3번: 무게 3 → OK, 가치 6

* 4번: 무게 5 → OK, 가치 12

👉 단일 선택 중 최대는 1번: 13 또는 4번: 12

## ✅ 2. 두 개 조합
* 1번(6) + 2번(4): 총 10kg ❌

* 1번(6) + 3번(3): 총 9kg ❌

* 1번(6) + 4번(5): 총 11kg ❌

* 2번(4) + 3번(3): ✅ 총 7kg, 가치 8 + 6 = 14

* 2번(4) + 4번(5): 4 + 5 = 9 ❌

* 3번(3) + 4번(5): 3 + 5 = 8 ❌

👉 2번 + 3번 조합이 가능하고, 가치 14로 현재 최고

## ✅ 3. 세 개 이상
2번(4) + 3번(3) + 4번(5) = 4 + 3 + 5 = 12kg ❌

그 외 조합도 무게 초과

👉 결국, 가능한 조합 중 최댓값은 14

---

## 힌트

* DP로 상태를 정의:
```python
dp[i][w] = i번째까지 물건 중에서 무게 w를 넘지 않게 담았을 때 최대 가치
```
* 점화식을 사용:
```python
dp[i][w] = dp[i-1][w] #i번째의 물건의 무게가 w보다 클 때

dp[i][w] = max(dp[i-1][w],              #i번째 물건을 선택하지 않았을 때
               dp[i-1][w-w[i]] + v[i])  #i번째 물건을 선택했을 때
                                        #물건을 가방에 넣었을 때와 넣지 않았을 때를 비교하여 최대값을 구함
```
---

## 문제 푼 코드

```python
"""
🎒 **0-1 배낭 문제 (0-1 Knapsack Problem) - 2차원 DP 버전**

📋 **문제 설명**:
- N개의 물건과 최대 무게 K인 배낭이 주어짐
- 각 물건은 무게(w)와 가치(v)를 가짐
- 배낭에 넣을 수 있는 물건들의 가치 합의 최댓값을 구하는 문제
- 각 물건은 0개 또는 1개만 선택 가능 (0-1 배낭)

🧠 **알고리즘**: 동적 계획법 (Dynamic Programming) - 2차원 배열 사용
⏰ **시간 복잡도**: O(N × K)
💾 **공간 복잡도**: O(N × K) - 메모리 사용량이 많지만 이해하기 쉬움

🔄 **1차원 DP와의 차이점**:
- 1차원: 공간 최적화, 역방향 순회 필요
- 2차원: 직관적 이해, 모든 상태 저장, 순방향 순회 가능
"""

# 📥 입력: n(물건 개수), k(배낭 최대 무게)
n, k = map(int, input().split())

# 🎯 2차원 DP 배열 초기화: dp[i][j] = i번째 물건까지 고려했을 때, 무게 j일 때의 최대 가치
# 행: 물건 인덱스 (0~n), 열: 무게 (0~k)
# 인덱스 1부터 사용하므로 크기는 (n+1) × (k+1)
dp = [[0 for i in range(k+1)] for i in range(n+1)]

# 🔄 각 물건에 대해 DP 테이블 채우기
for i in range(1, n+1):  # i번째 물건 (1부터 n까지)
    # 📥 현재 물건의 [무게, 가치] 입력
    # x[0]: 무게(weight), x[1]: 가치(value)
    x = list(map(int, input().split()))
    
    # 🎯 모든 가능한 무게에 대해 최적해 계산
    for j in range(1, k+1):  # j: 현재 고려하는 배낭 무게
        
        # ⚠️ **경우 1**: 현재 물건의 무게가 배낭 용량보다 큰 경우
        if x[0] > j:
            # 현재 물건을 넣을 수 없으므로 이전 상태 그대로 유지
            # dp[i-1][j]: (i-1)번째 물건까지 고려했을 때 무게 j의 최대 가치
            dp[i][j] = dp[i-1][j]
        
        # ✅ **경우 2**: 현재 물건을 넣을 수 있는 경우
        else:
            # 🤔 선택의 기로:
            # 1. dp[i-1][j]: 현재 물건을 넣지 않는 경우
            #    → (i-1)번째까지의 물건으로 무게 j일 때의 최대 가치
            # 2. dp[i-1][j-x[0]] + x[1]: 현재 물건을 넣는 경우
            #    → 무게 x[0]를 빼고 가치 x[1]을 더함
            #    → (i-1)번째까지의 물건으로 무게 (j-x[0])일 때의 최대 가치 + 현재 물건 가치
            # 🎯 두 경우 중 더 큰 값을 선택
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-x[0]] + x[1])

# 📤 결과 출력: n개의 물건을 모두 고려했을 때, 무게 k일 때의 최대 가치
print(dp[n][k])

"""
🔍 **2차원 DP 동작 예시**:

예시 입력:
4 7    # 물건 4개, 배낭 최대 무게 7
6 13   # 물건1: 무게 6, 가치 13
4 8    # 물건2: 무게 4, 가치 8  
3 6    # 물건3: 무게 3, 가치 6
5 12   # 물건4: 무게 5, 가치 12

초기 DP 테이블 (모든 값이 0):
      무게 0  1  2  3  4  5  6  7
물건0   0   0  0  0  0  0  0  0
물건1   0   0  0  0  0  0  0  0
물건2   0   0  0  0  0  0  0  0
물건3   0   0  0  0  0  0  0  0
물건4   0   0  0  0  0  0  0  0

물건1 (무게6, 가치13) 처리 후:
      무게 0  1  2  3  4  5  6   7
물건0   0   0  0  0  0  0  0   0
물건1   0   0  0  0  0  0  13  13
...

최종 DP 테이블:
      무게 0  1  2  3  4  5  6   7
물건0   0   0  0  0  0  0  0   0
물건1   0   0  0  0  0  0  13  13
물건2   0   0  0  0  8  8  13  13
물건3   0   0  0  6  8  8  14  19
물건4   0   0  0  6  8  12 14  20

결과: dp[4][7] = 20

🎯 **핵심 포인트**:

1️⃣ **2차원 DP의 의미**:
   - dp[i][j]: i번째 물건까지 고려했을 때, 무게 j일 때의 최대 가치
   - 각 셀은 이전 상태들을 참조하여 계산

2️⃣ **점화식**:
   if 무게 > j: dp[i][j] = dp[i-1][j]                    (물건을 넣을 수 없음)
   else:        dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)  (넣지않음 vs 넣음)

3️⃣ **메모리 사용**:
   - 모든 중간 상태를 저장: O(N × K) 공간
   - 1차원 버전보다 메모리 사용량 많음

4️⃣ **장점**:
   - 직관적이고 이해하기 쉬움
   - 역추적(backtracking)으로 선택된 물건 확인 가능
   - 디버깅이 용이함

5️⃣ **단점**:
   - 메모리 사용량이 많음
   - 큰 입력에서 메모리 초과 가능성
"""
```
---
