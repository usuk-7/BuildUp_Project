"""
📋 **문제 설명**:
- a와 b로 이루어진 문자열이 주어짐
- 길이가 2 이상인 같은 문자 그룹을 제거할 수 있음
- 이런 과정을 통해 빈 문자열로 만들 수 있는지 확인

🔍 **예시**:
- "babbbaaabb" → "baaaabb" → "bbb" → 빈 문자열 (가능)
- "aabbaabb" → 어떤 순서로도 빈 문자열 불가능

🧠 **알고리즘**: 재귀 + 메모이제이션
⏰ **시간 복잡도**: O(2^n) → O(n) (메모이제이션 효과)
💾 **공간 복잡도**: O(n) (재귀 스택 + 메모 딕셔너리)
"""

def can_make_empty(s: str, memo=None) -> bool:
    """
    문자열 s를 빈 문자열로 만들 수 있는지 확인하는 함수
    
    Args:
        s: 검사할 문자열 (a, b로만 구성)
        memo: 메모이제이션을 위한 딕셔너리
    
    Returns:
        bool: 빈 문자열로 만들 수 있으면 True, 없으면 False
    """
    # 🎯 메모이제이션 딕셔너리 초기화 (첫 호출 시에만)
    if memo is None:
        memo = {}

    # 🔍 이미 계산된 결과가 있으면 바로 반환 (중복 계산 방지)
    if s in memo:
        return memo[s]

    # ✅ 베이스 케이스: 이미 빈 문자열이면 성공
    if not s:
        return True

    # 🔄 문자열을 순회하면서 연속된 같은 문자 그룹 찾기
    i = 0
    while i < len(s):
        j = i
        # 같은 문자가 연속으로 나오는 구간의 끝 찾기
        while j < len(s) and s[j] == s[i]:
            j += 1

        # 🎯 길이가 2 이상인 그룹을 찾으면 제거 시도
        if j - i >= 2:
            # 현재 그룹 [i:j]을 제거한 새로운 문자열 생성
            new_s = s[:i] + s[j:]
            
            # 🔄 제거 후 남은 문자열에 대해 재귀 호출
            if can_make_empty(new_s, memo):
                memo[s] = True  # 🗃️ 결과 저장
                return True

        # 다음 그룹으로 이동
        i = j

    # 😞 어떤 그룹도 제거할 수 없거나 제거해도 빈 문자열이 되지 않음
    memo[s] = False  # 🗃️ 결과 저장
    return False

def main():
    """메인 함수: 입력 처리 및 결과 출력"""
    # 📥 테스트 케이스 개수 입력
    T = int(input().strip())
    
    # 🔄 각 테스트 케이스 처리
    for _ in range(T):
        # 📥 문자열 입력 (a, b로만 구성)
        s = input().strip()
        
        # 🎯 빈 문자열로 만들 수 있는지 확인
        # 가능하면 1, 불가능하면 0 출력
        result = 1 if can_make_empty(s) else 0
        print(result)

if __name__ == "__main__":
    main()

"""
🔍 **알고리즘 동작 예시**:

예시 1: "babbbaaabb"
1. "babbbaaabb" → "bbb" 제거 → "baaaabb"
2. "baaaabb" → "aaaa" 제거 → "bbb"  
3. "bbb" → "bbb" 제거 → "" (빈 문자열)
결과: 1 (가능)

예시 2: "aabbaabb"
- 모든 가능한 제거 순서를 시도해도 빈 문자열 불가능
결과: 0 (불가능)

🎯 **핵심 아이디어**:

1️⃣ **그룹 찾기**: 연속된 같은 문자 2개 이상을 그룹으로 인식
2️⃣ **백트래킹**: 모든 가능한 제거 순서를 재귀적으로 탐색
3️⃣ **메모이제이션**: 같은 문자열 상태는 한 번만 계산
4️⃣ **조기 종료**: 빈 문자열이 되는 경로를 찾으면 즉시 반환

⚡ **최적화 기법**:
- 메모이제이션으로 중복 계산 방지
- 성공하는 경우 즉시 True 반환
- 문자열 길이가 줄어들수록 계산 시간 단축

🎓 **시간 복잡도 분석**:
- 메모이제이션 없이: O(2^n) - 모든 가능한 제거 순서
- 메모이제이션 적용: O(n × 가능한 문자열 상태 수)
"""