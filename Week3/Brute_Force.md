# 📝 Brute Force 알고리즘

## 1. 개요

아래에서는 **Brute Force (무차별 대입법)** 기법의 개념을 설명하고, 이를 이용해 주어진 문자열 그룹 제거 문제를 해결하는 방법을 제시하고 있다. 본 문제는 문자열 내의 일정 조건을 만족하는 그룹을 반복적으로 제거하여 **빈 문자열**로 만들 수 있는지 여부를 판단하는 문제이다.

---

## 2. Brute Force 기법이란?

### 정의

Brute Force는 완전탐색 알고리즘, 즉, 가능한 모든 경우의 수를 탐색하여 정답을 찾는 방식이다. 최적화보다는 **모든 가능성을 시도**하기 때문에 구현이 간단하고 확실한 정답을 보장한다.

### 장점

- 구현이 단순하다.
- 모든 가능성을 고려하므로 해를 반드시 찾을 수 있다 (존재할 경우).

### 단점

- 시간 복잡도가 높고, 비효율적일 수 있다.
- 입력의 크기가 커지면 성능이 급격히 저하된다.

### 🔍 동작 방식 예시

#### 📌 예제 1: 비밀번호 찾기

어떤 웹사이트 비밀번호가 4자리 숫자라고 할 때, Brute Force는 다음과 같이 동작한다.

```python
for pw in range(10000):  # 0000 ~ 9999
    if try_password(str(pw).zfill(4)):
        print("비밀번호는", str(pw).zfill(4))
        break
```
→ 가능한 0000부터 9999까지 모든 숫자를 시도해서 정답을 찾는 방식이다.

#### 📌 예제 2: 배열에서 두 수의 합이 특정 값이 되는 쌍 찾기

```python
arr = [1, 3, 5, 7, 9]
target = 10

for i in range(len(arr)):
    for j in range(i + 1, len(arr)):
        if arr[i] + arr[j] == target:
            print(arr[i], arr[j])
```

→ 배열에서 두 수의 합이 `target`인 모든 조합을 시도하여 조건을 만족하는 경우를 찾는다.

---

## 3. 참고 문제 : 백준 8913번 문자열 뽑기

### 문제

a와 b로만 이루어진 문자열 s이 있다. 그룹은 같은 글자로 이루어진 가장 긴 연속 부분 문자열이다. 길이가 2 이상인 s의 모든 그룹 g는 제거할 수(뽑을 수) 있고, 남은 왼쪽 부분과 오른쪽 부분을 연결해서 새 문자열을 만들 수 있다. 이러한 과정은 문자열이 빈 문자열이 되거나, 길이가 2 이상인 그룹이 없을 때 까지 계속한다.

예를 들어, s = babbbaaabb일 때, s에는 그룹이 다섯 개 있다. s는 다음과 같은 단계를 거쳐서 빈 문자열로 바꿀 수 있다. (밑 줄이 그어져 있는 그룹이 뽑히는 그룹)

`babbbaaabb → baaaabb → bbb → 빈 문자열`

하지만, 아래와 같은 단계를 거친다면, 빈 문자열로 바꿀 수 없다.

`babbbaaabb → babbbaaa → baaaa → b`

문자열이 주어졌을 때, 적절한 과정을 거쳐 빈 문자로 바꿀 수 있는지 없는지를 구하는 프로그램을 작성하시오.

### 예제 입력

```
3
babbbaaabb
aabbaabb
abab
```

---

### 예제 출력

```
1
1
0
```

---

## 4. 해결 전략 (Brute Force 방식)

### 핵심 아이디어

1. 문자열 내에 길이 ≥ 2인 연속 그룹을 찾는다.
2. 해당 그룹을 제거한 문자열로 재귀적으로 같은 작업을 반복한다.
3. 문자열이 빈 문자열이 되면 성공, 더 이상 제거할 그룹이 없으면 실패.

### 알고리즘 흐름

```python
def can_make_empty(s: str, memo=None) -> bool:
    if memo is None:
        memo = {}

    if s in memo:
        return memo[s]

    if not s:
        return True

    i = 0
    while i < len(s):
        j = i
        while j < len(s) and s[j] == s[i]:
            j += 1

        if j - i >= 2:
            new_s = s[:i] + s[j:]

            if can_make_empty(new_s, memo):
                memo[s] = True
                return True

        i = j

    memo[s] = False
    return False
```

---

## 5. 전체 구현

```python
"""
📋 **문제 설명**:
- a와 b로 이루어진 문자열이 주어짐
- 길이가 2 이상인 같은 문자 그룹을 제거할 수 있음
- 이런 과정을 통해 빈 문자열로 만들 수 있는지 확인

🔍 **예시**:
- "babbbaaabb" → "baaaabb" → "bbb" → 빈 문자열 (가능)
- "aabbaabb" → 어떤 순서로도 빈 문자열 불가능

🧠 **알고리즘**: 재귀 + 메모이제이션
⏰ **시간 복잡도**: O(2^n) → O(n) (메모이제이션 효과)
💾 **공간 복잡도**: O(n) (재귀 스택 + 메모 딕셔너리)
"""

def can_make_empty(s: str, memo=None) -> bool:
    """
    문자열 s를 빈 문자열로 만들 수 있는지 확인하는 함수

    Args:
        s: 검사할 문자열 (a, b로만 구성)
        memo: 메모이제이션을 위한 딕셔너리

    Returns:
        bool: 빈 문자열로 만들 수 있으면 True, 없으면 False
    """
    # 🎯 메모이제이션 딕셔너리 초기화 (첫 호출 시에만)
    if memo is None:
        memo = {}

    # 🔍 이미 계산된 결과가 있으면 바로 반환 (중복 계산 방지)
    if s in memo:
        return memo[s]

    # ✅ 베이스 케이스: 이미 빈 문자열이면 성공
    if not s:
        return True

    # 🔄 문자열을 순회하면서 연속된 같은 문자 그룹 찾기
    i = 0
    while i < len(s):
        j = i
        # 같은 문자가 연속으로 나오는 구간의 끝 찾기
        while j < len(s) and s[j] == s[i]:
            j += 1

        # 🎯 길이가 2 이상인 그룹을 찾으면 제거 시도
        if j - i >= 2:
            # 현재 그룹 [i:j]을 제거한 새로운 문자열 생성
            new_s = s[:i] + s[j:]

            # 🔄 제거 후 남은 문자열에 대해 재귀 호출
            if can_make_empty(new_s, memo):
                memo[s] = True  # 🗃️ 결과 저장
                return True

        # 다음 그룹으로 이동
        i = j

    # 😞 어떤 그룹도 제거할 수 없거나 제거해도 빈 문자열이 되지 않음
    memo[s] = False  # 🗃️ 결과 저장
    return False

def main():
    """메인 함수: 입력 처리 및 결과 출력"""
    # 📥 테스트 케이스 개수 입력
    T = int(input().strip())

    # 🔄 각 테스트 케이스 처리
    for _ in range(T):
        # 📥 문자열 입력 (a, b로만 구성)
        s = input().strip()

        # 🎯 빈 문자열로 만들 수 있는지 확인
        # 가능하면 1, 불가능하면 0 출력
        result = 1 if can_make_empty(s) else 0
        print(result)

if __name__ == "__main__":
    main()

"""
🔍 **알고리즘 동작 예시**:

예시 1: "babbbaaabb"
1. "babbbaaabb" → "bbb" 제거 → "baaaabb"
2. "baaaabb" → "aaaa" 제거 → "bbb"
3. "bbb" → "bbb" 제거 → "" (빈 문자열)
결과: 1 (가능)

예시 2: "aabbaabb"
- 모든 가능한 제거 순서를 시도해도 빈 문자열 불가능
결과: 0 (불가능)

🎯 **핵심 아이디어**:

1️⃣ **그룹 찾기**: 연속된 같은 문자 2개 이상을 그룹으로 인식
2️⃣ **백트래킹**: 모든 가능한 제거 순서를 재귀적으로 탐색
3️⃣ **메모이제이션**: 같은 문자열 상태는 한 번만 계산
4️⃣ **조기 종료**: 빈 문자열이 되는 경로를 찾으면 즉시 반환

⚡ **최적화 기법**:
- 메모이제이션으로 중복 계산 방지
- 성공하는 경우 즉시 True 반환
- 문자열 길이가 줄어들수록 계산 시간 단축

🎓 **시간 복잡도 분석**:
- 메모이제이션 없이: O(2^n) - 모든 가능한 제거 순서
- 메모이제이션 적용: O(n × 가능한 문자열 상태 수)
"""
```

---

## 6. 시간 복잡도 분석

- 최악의 경우 모든 가능한 그룹 제거 순서를 탐색해야 하므로 \*\*지수 시간복잡도 (O(2^n))\*\*에 가깝다.
- 문자열 최대 길이가 25이므로 현실적으로 해결이 가능하다.
